.286 ; без него почему то не работала операция shr

cseg segment para public 'code'
	assume cs:cseg
    org 100h ; размер psp. вся адресация смещается 256 байт

start:  jmp load ;переход на нерезидентную часть
        old dd  0 ; адрес старого обработчика таймера. это нужно когда будет вызываться старый обработчик прерываний от таймера
        buf db ' 00:00:00 ', 0 ; выводимая строка

decode proc ;перевод в аски и запись времени в буф
    mov ah, al
    and al, 15; преобразование 2-10 числа в аски символ
    shr ah, 4
    add al, '0'
    add ah, '0'
    mov buf[bx + 1], ah
    mov buf[bx + 2], al
    add bx, 3 ; увеличиваем т.к. 2 "символа времени" + ":"
    ret
decode  endp

clock proc ; обработка прерываний от таймер
    pushf ; в стек помещаются регистр Flags
    call cs:old ; вызывается старый обработчик прерываний
    push ds ; сохраняем значения регистров до вызова прерывания, чтобы не потерять их значения
    push es
	push ax
	push bx
    push cx
    push dx
	push di
    push cs
     
    pop ds; выгружаем для дальнейшей работы с ячейками памяти

    mov ah, 2
    int 1Ah ; получаем текущее время

    xor bx, bx ; запись начать сначала(строка 16)
    mov al, ch ; часы
    call decode
    mov al, cl ; минуты
    call decode
    mov al, dh ; секунды
    call decode

    mov ax, 0B800h; видеопамять 
    mov es, ax ; в es перемещаем сегмент видеопамяти
    mov di, 140 ; перемещение в правый верхний угол
    xor bx, bx ; обнуление так как надо заново вывести время
    mov ah, 1Bh; атрибуты выводимых символов

metka_1: 
    mov al, buf[bx] 
    stosw ; запись очередного символа и атрибута, точнее ах загружается в es:di и в зависимости от df, di += 2 или -= 2
    ; df флаг контроля обработки строки
    inc bx
    cmp buf[bx],  0 ; пока не конец буфера, продолжить
    jnz metka_1

metka_2:    ; восстановление регистров, сегментов
    pop di
    pop dx
    pop cx
    pop bx
    pop ax
    pop es
    pop ds
    iret ; возвращаемся из обработчика
clock endp

end_clock: ; это очень важно т.к здесь я определаю размер резидентной части

load:   
    mov ax, 351Ch ; получаю адрес старого обработчика. 1ch - системный обработчик таймера
    int 21h
    mov word ptr old, bx ; сохранение смещения обработчика. word ptr явное определение типа
    mov word ptr old + 2, es ; сохранение сегмента обработчика
    mov ax, 251Ch ; устанавливается адрес обработчика
    mov dx, offset clock 
    int 21h
    mov ax, 31h ; завершение резидентной программы
    mov dx, (end_clock - start + 10Fh) / 16 ; определение резидентной части программы в параграфах(/16)
    int 21h
cseg ends
     end start
